<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGPU Triangle</title>
</head>
<body>
  <canvas id="canvas" width="640" height="480"></canvas>

  <!-- WGSL shader -->
  <script id="shader" type="x-shader/wgsl">
    struct VertexOutput {
      @builtin(position) clip_position: vec4<f32>,
    };

    @vertex
    fn vs_main(@location(0) inPos: vec3<f32>) -> VertexOutput {
      var out: VertexOutput;
      out.clip_position = vec4<f32>(inPos, 1.0);
      return out;
    }

    @fragment
    fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
      return vec4<f32>(0.3, 0.9, 0.1, 1.0);
    }
  </script>

  <script type="module">
    async function webgpu() {
      if (!navigator.gpu) {
        throw new Error("WebGPU not supported in this browser");
      }

      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      const canvas = document.getElementById("canvas");
      const context = canvas.getContext("webgpu");

      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: format
      });

      // Load shader code from the script tag
      const shaderCode = document.getElementById("shader").textContent;
      const shaderModule = device.createShaderModule({ code: shaderCode });

      // Vertex buffer - defines the triangle corners
      const positions = new Float32Array([
        .8, -0.8, 0.0,
       -.7, -.6, 0.0,
        0.2,  .8, 0.0
      ]);

      const positionBuffer = device.createBuffer({
        size: positions.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(positionBuffer, 0, positions);

      const vertexBufferLayout = {
        arrayStride: 12, // 3 floats * 4 bytes
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      };

      // Pipeline
      const pipeline = device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: shaderModule,
          entryPoint: "vs_main",
          buffers: [vertexBufferLayout]
        },
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: [{ format }]
        },
        primitive: {
          topology: "triangle-list"
        }
      });

      // Render pass
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();
      const renderPass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: textureView,
          clearValue: { r: 0.9, g: 0.2, b: 0.2, a: 1.0 },
          loadOp: "clear",
          storeOp: "store"
        }]
      });

      renderPass.setPipeline(pipeline);
      renderPass.setVertexBuffer(0, positionBuffer);
      renderPass.draw(3, 1, 0, 0);
      renderPass.end();

      device.queue.submit([commandEncoder.finish()]);
    }

    webgpu();
  </script>
</body>
</html>
