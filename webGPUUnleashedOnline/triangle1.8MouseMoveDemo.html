<html>
<!-- **********************************************************************************
 
Mouse interaction starting with webGPU Unleashed section 1.9

Mouse movement interacts with the transform matrix
Each type of transform (scale, translate, rotate ) are applied to the transform buffer
used in the example.

The original single-pass pipeline gets wrapped in the draw() function, which is called
whenever the mouse is moved.




Notes:  Another implementation uses the method of constantly refreshing the frame even 
so it acts more like a timer event constantly firing.

************************************************************************************** -->

<body>
    <p>left mouse: translate right mouse z-rotate, wheel: scale</p>
    <canvas id="canvas" width="640" height="480"></canvas>
</body>
<script src="../utils/utils.js"></script>
<script src="../utils/gl-matrix.js">
//transformation matrix </script>
<script id="shader" type="wgsl">
// Vertex shader
@group(0) @binding(0)
var<uniform> transform: mat4x4<f32>;
struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex_coords: vec2<f32>,
};
@vertex
fn vs_main(
    @location(0) inPos: vec3<f32>,
    @location(1) inTexCoords: vec2<f32>
) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = transform * vec4<f32>(inPos, 1.0);
    out.tex_coords = inTexCoords;
    return out;
}
// Fragment shader

@group(0) @binding(1)
var t_diffuse: texture_2d<f32>;
@group(0) @binding(2)
var s_diffuse: sampler;

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return textureSample(t_diffuse, s_diffuse, in.tex_coords);
}

</script>

<script>
    //helper  img2texture
    async function webgpu() {
        if (!navigator.gpu) {
            showWarning("WebGPU support is not available. A WebGPU capable browser is required to run this sample.");
            throw new Error("WebGPU support is not available");
        }
        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        let device = await adapter.requestDevice();
        console.log(device);

        const context = configContext(device, canvas);

        // create shaders
        const texture = await img2texture(device, '../data/baboon.png');

        const sampler = device.createSampler({
            addressModeU: 'repeat',
            addressModeV: 'repeat',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
        });

        let shaderModule = shaderModuleFromCode(device, 'shader');

        const positionAttribDesc = {
            shaderLocation: 0, // @location(0)
            offset: 0,
            format: 'float32x3'
        };

        const positionBufferLayoutDesc = {
            attributes: [positionAttribDesc],
            arrayStride: 4 * 3, // sizeof(float) * 3
            stepMode: 'vertex'
        };

        const texCoordsAttribDesc = {
            shaderLocation: 1, // @location(1)
            offset: 0,
            format: 'float32x2'
        };

        const texCoordsBufferLayoutDesc = {
            attributes: [texCoordsAttribDesc],
            arrayStride: 4 * 2, // sizeof(float) * 3
            stepMode: 'vertex'
        };

        const positions = new Float32Array([
            1.0, -1.0, 0.0,   // right bottom - position of this vertex
            -1.0, -1.0, 0.0,  // left bottom
            0.0, 1.0, 0.0     // middle top
        ]);

        let positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);

        // this defines the source locations of the image (the gorilla)
        const texCoords = new Float32Array([
            1.0, 0.0,   // right top // 0..1 left-right, top-bottom image source of first vertex
            0.0, 0.0,   // left top
            0.5, 1.0,   // middle bottom (chin)

        ]);

        let texCoordsBuffer = createGPUBuffer(device, texCoords, GPUBufferUsage.VERTEX);
        let translateMatrix = glMatrix.mat4.fromTranslation(
            glMatrix.mat4.create(), 
            glMatrix.vec3.fromValues(-0.5, -0.5, 0.0));  // initial x,y,z position


        // COPY_DST is required if I want to be able to update the GPU transform matrix
        let uniformBuffer = createGPUBuffer(device, translateMatrix, 
            GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST );


        let uniformBindGroupLayout = device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {}
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {}
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {}
                }
            ]
        });

        let uniformBindGroup = device.createBindGroup({
            layout: uniformBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: uniformBuffer
                    }
                },
                {
                    binding: 1,
                    resource: texture.createView()
                },
                {
                    binding: 2,
                    resource:
                        sampler

                }
            ]
        });

        const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
        const layout = device.createPipelineLayout(pipelineLayoutDesc);

        const colorState = {
            format: navigator.gpu.getPreferredCanvasFormat()  //'bgra8unorm'
        };

        const pipelineDesc = {
            layout,
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [positionBufferLayoutDesc, texCoordsBufferLayoutDesc]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [colorState]
            },
            primitive: {
                topology: 'triangle-list',
                frontFace: 'cw',
                cullMode: 'back'
            }
        };

        pipeline = device.createRenderPipeline(pipelineDesc);

        // ****************************************************************************
        // handle mouse movement
        // global variables
        // ****************************************************************************

        let dragging = false;
        let lastX = 0;
        let lastY = 0;

        // handle rotation
        let rotX = 0;
        let rotY = 0;

        // scaling
        let scale = 1.0;

        let draggingMode = 0; // 0 = rotate, 2 = translate


        // track our total translation
        // initial values are from the original demo (normalized distance)
        let tx = -0.5;  // to the left
        let ty = -0.5;  // down

        // handle translation - mouse drag
        //  mousedown, mousemove
        // canvas object is the bounding event receiver
        window.addEventListener("mousedown", 
            (e) => {

                e.preventDefault(); // pright-click defaults

                // when mouse-down  (don't forget handle mouseup )
                dragging = true;
                lastX = e.clientX;
                lastY = e.clientY;

                draggingMode = e.button;

                console.log("dmode: " + draggingMode);
            }, {passive:false});

        // prevent the defautl right-click behavior
        window.addEventListener("contextmenu", e => e.preventDefault());


        window.addEventListener("wheel", e => {
            e.preventDefault(); // prevents page scrolling

            // scroll up → zoom in, scroll down → zoom out
            const zoomSpeed = 0.001;
            scale += -e.deltaY * zoomSpeed;
            // console.log("scale: " + scale );

            // clamp scale to avoid flipping or disappearing
            scale = Math.max(0.1, Math.min(scale, 10.0));

            updateTransform()

            draw();
        }, 
        { passive: false }); // allow preventDefault() to work

        window.addEventListener("mousemove",
            (e) => {
                if( !dragging ) return; // do nothing if not dragging
                                
                let dx = e.clientX - lastX;
                let dy = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;

                const dxClip = (2 * dx) / canvas.width;
                const dyClip = (2 * dy) / canvas.height;

                if (draggingMode === 2) { // right MOUSE → ROTATION 

                    rotY += dx * 0.01; // horizontal drag rotates around Y 
                    rotX += dy * 0.01; // vertical drag rotates around X

                } else if (draggingMode === 0) {

                    tx += dxClip;
                    ty -= dyClip;   // dyClip already has correct sign if you invert above

                    //tx += dx * .002; // scale down to the -1..1 smaller coordinates
                    //ty -= dy * .002; 

                    // create a new translation matrix and update the buffer
                    // glMatrix.mat4.fromTranslation(translateMatrix, [tx, ty, -2]);
                    // glMatrix.mat4.fromTranslation(translateMatrix, [tx, ty, 0]);
                    // device.queue.writeBuffer(uniformBuffer, 0, translateMatrix);
                }

                updateTransform();

                draw(); // only redraw on mouse move!

            }
        )

        window.addEventListener("mouseup", 
            (e) => {
                // when mouse-down  (don't forget handle mouseup )
                dragging = false;
            });


        function updateTransform() {
                
            // Build TRS matrix 
            const m = glMatrix.mat4.create(); 
            glMatrix.mat4.translate(m, m, [tx, ty, 0]); 
            glMatrix.mat4.rotateZ(m, m, rotX); 
            glMatrix.mat4.rotateZ(m, m, rotY);

            // Scaling 
            glMatrix.mat4.scale(m, m, [scale, scale, scale]);

            device.queue.writeBuffer(uniformBuffer, 0, m);
        }


        // ******************************************************************************
        // ******************************************************************************
        //
        // this code is wrapped in a function frame() taken verbatum from original code
        function draw() {

            // this is the original code from the example
            let colorTexture = context.getCurrentTexture();
            let colorTextureView = colorTexture.createView();

            // this determines the color of the canvas
            let colorAttachment = {
                view: colorTextureView,
                clearValue: { r: 0.5, g: 0.5, b: 0.5, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
            };

            const renderPassDesc = {
                colorAttachments: [colorAttachment]
            };
            commandEncoder = device.createCommandEncoder();

            passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
            passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, uniformBindGroup);
            passEncoder.setVertexBuffer(0, positionBuffer);
            passEncoder.setVertexBuffer(1, texCoordsBuffer);
            passEncoder.draw(3, 1);
            passEncoder.end();

            device.queue.submit([commandEncoder.finish()]);

            // requestAnimationFrame(frame); // run frame() as fast as we can loop

        } // end of draw()

        // ****************************************************************************
        // ****************************************************************************

        draw();  // re-render every mouse movement/animation
        // requestAnimationFrame(frame); // run frame() as fast as we can loop
        
    }  // end of webgpu() - original code

    webgpu();
</script>

</html>
