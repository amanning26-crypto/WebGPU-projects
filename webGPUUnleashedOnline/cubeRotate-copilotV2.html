<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGPU Rotating Cube</title>
  <style>
    body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; }
    canvas { border: 1px solid #444; }
  </style>
</head>
<body>
<canvas id="canvas" width="640" height="480"></canvas>

<script type="module">
const canvas = document.getElementById('canvas');

async function init() {
  if (!navigator.gpu) {
    alert("WebGPU not supported");
    return;
  }

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();

  const context = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();
  context.configure({
    device,
    format,
    alphaMode: 'opaque',
    size: [canvas.width, canvas.height]
  });

  const shaderCode = /* wgsl */`
struct Uniforms {
  mvp : mat4x4<f32>,
};
@group(0) @binding(0) var<uniform> u : Uniforms;

struct VSOut {
  @builtin(position) position : vec4<f32>,
  @location(0) color : vec3<f32>,
};

@vertex
fn vs_main(
  @location(0) position : vec3<f32>,
  @location(1) color : vec3<f32>
) -> VSOut {
  var out : VSOut;
  out.position = u.mvp * vec4<f32>(position, 1.0);
  out.color = color;
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return vec4<f32>(in.color, 1.0);
}
`;

  const shaderModule = device.createShaderModule({ code: shaderCode });

  // Cube vertices: position (x,y,z) + color (r,g,b)
  const vertices = new Float32Array([
    // Front face (Z+)
    -1, -1,  1,   1, 0, 0,
     1, -1,  1,   0, 1, 0,
     1,  1,  1,   0, 0, 1,
    -1,  1,  1,   1, 1, 0,
    // Back face (Z-)
    -1, -1, -1,   1, 0, 1,
     1, -1, -1,   0, 1, 1,
     1,  1, -1,   1, 1, 1,
    -1,  1, -1,   0.2, 0.2, 0.2,
  ]);

  const indices = new Uint16Array([
    // Front
    0, 1, 2,  0, 2, 3,
    // Back
    4, 6, 5,  4, 7, 6,
    // Left
    4, 0, 3,  4, 3, 7,
    // Right
    1, 5, 6,  1, 6, 2,
    // Top
    3, 2, 6,  3, 6, 7,
    // Bottom
    4, 5, 1,  4, 1, 0
  ]);

  const vertexBuffer = device.createBuffer({
    size: vertices.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertices);

  const indexBuffer = device.createBuffer({
    size: indices.byteLength,
    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(indexBuffer, 0, indices);

  const uniformBufferSize = 64; // 4x4 matrix
  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  const uniformBindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: { type: 'uniform' }
      }
    ]
  });

  const uniformBindGroup = device.createBindGroup({
    layout: uniformBindGroupLayout,
    entries: [
      {
        binding: 0,
        resource: { buffer: uniformBuffer }
      }
    ]
  });

  const pipeline = device.createRenderPipeline({
    layout: device.createPipelineLayout({
      bindGroupLayouts: [uniformBindGroupLayout]
    }),
    vertex: {
      module: shaderModule,
      entryPoint: 'vs_main',
      buffers: [
        {
          arrayStride: 6 * 4,
          attributes: [
            { shaderLocation: 0, offset: 0, format: 'float32x3' },
            { shaderLocation: 1, offset: 3 * 4, format: 'float32x3' }
          ]
        }
      ]
    },
    fragment: {
      module: shaderModule,
      entryPoint: 'fs_main',
      targets: [{ format }]
    },
    primitive: {
      topology: 'triangle-list',
      cullMode: 'back'
    },
    depthStencil: {
      format: 'depth24plus',
      depthWriteEnabled: true,
      depthCompare: 'less'
    }
  });

  const depthTexture = device.createTexture({
    size: [canvas.width, canvas.height],
    format: 'depth24plus',
    usage: GPUTextureUsage.RENDER_ATTACHMENT
  });

  // Column-major mat4 helpers
  function mat4Identity() {
    return new Float32Array([
      1,0,0,0,
      0,1,0,0,
      0,0,1,0,
      0,0,0,1
    ]);
  }

  // Correct column-major multiply: out = a * b
  function mat4Multiply(a, b) {
    const out = new Float32Array(16);
    for (let col = 0; col < 4; ++col) {
      for (let row = 0; row < 4; ++row) {
        out[col*4 + row] =
          a[0*4 + row] * b[col*4 + 0] +
          a[1*4 + row] * b[col*4 + 1] +
          a[2*4 + row] * b[col*4 + 2] +
          a[3*4 + row] * b[col*4 + 3];
      }
    }
    return out;
  }

  function mat4Perspective(fovY, aspect, near, far) {
    const f = 1.0 / Math.tan(fovY / 2);
    const nf = 1 / (near - far);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;

    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;

    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;

    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  }

  function mat4Translate(tx, ty, tz) {
    const out = mat4Identity();
    out[12] = tx;
    out[13] = ty;
    out[14] = tz;
    return out;
  }

  function mat4RotateX(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const out = mat4Identity();
    out[5] = c;
    out[6] = s;
    out[9] = -s;
    out[10] = c;
    return out;
  }

  function mat4RotateY(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const out = mat4Identity();
    out[0] = c;
    out[2] = -s;
    out[8] = s;
    out[10] = c;
    return out;
  }

  // Interaction state
  let angleX = 0;
  let angleY = 0;
  let dragging = false;
  let lastX = 0;
  let lastY = 0;

  // Auto-rotation speed (radians per second)
  let autoSpeedX = 0.4;
  let autoSpeedY = 0.6;

  canvas.addEventListener('mousedown', (e) => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener('mouseup', () => {
    dragging = false;
  });

  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    angleY += dx * 0.01;
    angleX += dy * 0.01;
  });

  // Adjust auto-rotation speed with keys
  window.addEventListener('keydown', (e) => {
    if (e.key === '+') {
      autoSpeedX *= 1.2;
      autoSpeedY *= 1.2;
    } else if (e.key === '-') {
      autoSpeedX *= 0.8;
      autoSpeedY *= 0.8;
    } else if (e.key === '0') {
      autoSpeedX = 0;
      autoSpeedY = 0;
    }
  });

  let lastTime = performance.now();

  function frame(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    if (!dragging) {
      angleX += autoSpeedX * dt;
      angleY += autoSpeedY * dt;
    }

    const aspect = canvas.width / canvas.height;
    const proj = mat4Perspective(Math.PI / 3, aspect, 0.1, 100.0);
    const view = mat4Translate(0, 0, -5);
    const rotX = mat4RotateX(angleX);
    const rotY = mat4RotateY(angleY);
    const model = mat4Multiply(rotY, rotX);
    const mv = mat4Multiply(view, model);
    const mvp = mat4Multiply(proj, mv);

    device.queue.writeBuffer(uniformBuffer, 0, mvp);

    const colorTexture = context.getCurrentTexture();
    const colorView = colorTexture.createView();
    const depthView = depthTexture.createView();

    const commandEncoder = device.createCommandEncoder();
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: colorView,
        clearValue: { r: 0.1, g: 0.1, b: 0.12, a: 1 },
        loadOp: 'clear',
        storeOp: 'store'
      }],
      depthStencilAttachment: {
        view: depthView,
        depthClearValue: 1.0,
        depthLoadOp: 'clear',
        depthStoreOp: 'store'
      }
    });

    pass.setPipeline(pipeline);
    pass.setBindGroup(0, uniformBindGroup);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.setIndexBuffer(indexBuffer, 'uint16');
    pass.drawIndexed(indices.length);
    pass.end();

    device.queue.submit([commandEncoder.finish()]);
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

init();
</script>
</body>
</html>
