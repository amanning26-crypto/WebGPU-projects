<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GPU-side Matrix Cube</title>
<style>
  body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; }
  canvas { border: 1px solid #444; }
</style>
</head>
<body>
<canvas id="c" width="640" height="480"></canvas>

<script type="module">
const canvas = document.getElementById("c");

async function main() {
  if (!navigator.gpu) { alert("WebGPU not supported"); return; }

  const adapter = await navigator.gpu.requestAdapter();
  const device = await adapter.requestDevice();

  const context = canvas.getContext("webgpu");
  const format = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format, alphaMode: "opaque" });

  // ---------------------------
  // Cube vertex data
  // ---------------------------
  const vertices = new Float32Array([
    // pos              // color
    -1,-1, 1,   1,0,0,
     1,-1, 1,   0,1,0,
     1, 1, 1,   0,0,1,
    -1, 1, 1,   1,1,0,
    -1,-1,-1,   1,0,1,
     1,-1,-1,   0,1,1,
     1, 1,-1,   1,1,1,
    -1, 1,-1,   0.2,0.2,0.2,
  ]);

  const indices = new Uint16Array([
    0,1,2, 0,2,3,
    4,6,5, 4,7,6,
    4,0,3, 4,3,7,
    1,5,6, 1,6,2,
    3,2,6, 3,6,7,
    4,5,1, 4,1,0
  ]);

  const vbuf = device.createBuffer({
    size: vertices.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(vbuf, 0, vertices);

  const ibuf = device.createBuffer({
    size: indices.byteLength,
    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(ibuf, 0, indices);

  // ---------------------------
  // Uniforms: angles only
  // ---------------------------
  const uniformBuffer = device.createBuffer({
    size: 16, // angleX, angleY, padding
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });

  // ---------------------------
  // WGSL shader
  // ---------------------------
  const shader = device.createShaderModule({
    code: `
struct Uniforms {
  angleX : f32,
  angleY : f32,
  pad1 : f32,
  pad2 : f32,
};
@group(0) @binding(0) var<uniform> u : Uniforms;

struct VSOut {
  @builtin(position) pos : vec4<f32>,
  @location(0) color : vec3<f32>,
};

fn rotX(a : f32) -> mat4x4<f32> {
  let c = cos(a);
  let s = sin(a);
  return mat4x4<f32>(
    vec4<f32>(1,0,0,0),
    vec4<f32>(0,c,s,0),
    vec4<f32>(0,-s,c,0),
    vec4<f32>(0,0,0,1)
  );
}

fn rotY(a : f32) -> mat4x4<f32> {
  let c = cos(a);
  let s = sin(a);
  return mat4x4<f32>(
    vec4<f32>(c,0,-s,0),
    vec4<f32>(0,1,0,0),
    vec4<f32>(s,0,c,0),
    vec4<f32>(0,0,0,1)
  );
}

fn perspective(fov : f32, aspect : f32, near : f32, far : f32) -> mat4x4<f32> {
  let f = 1.0 / tan(fov * 0.5);
  let nf = 1.0 / (near - far);
  return mat4x4<f32>(
    vec4<f32>(f/aspect,0,0,0),
    vec4<f32>(0,f,0,0),
    vec4<f32>(0,0,(far+near)*nf,-1),
    vec4<f32>(0,0,(2.0*far*near)*nf,0)
  );
}

@vertex
fn vs_main(
  @location(0) pos : vec3<f32>,
  @location(1) col : vec3<f32>
) -> VSOut {
  let aspect = 640.0 / 480.0;
  let proj = perspective(3.14159/3.0, aspect, 0.1, 100.0);
  let view = mat4x4<f32>(
    vec4<f32>(1,0,0,0),
    vec4<f32>(0,1,0,0),
    vec4<f32>(0,0,1,0),
    vec4<f32>(0,0,-5,1)
  );

  let model = rotY(u.angleY) * rotX(u.angleX);
  let mvp = proj * view * model;

  var out : VSOut;
  out.pos = mvp * vec4<f32>(pos, 1.0);
  out.color = col;
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return vec4<f32>(in.color, 1.0);
}
`
  });

  // ---------------------------
  // Pipeline
  // ---------------------------
  const pipeline = device.createRenderPipeline({
    layout: "auto",
    vertex: {
      module: shader,
      entryPoint: "vs_main",
      buffers: [{
        arrayStride: 6 * 4,
        attributes: [
          { shaderLocation: 0, offset: 0, format: "float32x3" },
          { shaderLocation: 1, offset: 3*4, format: "float32x3" }
        ]
      }]
    },
    fragment: {
      module: shader,
      entryPoint: "fs_main",
      targets: [{ format }]
    },
    primitive: { topology: "triangle-list", cullMode: "back" },
    depthStencil: {
      format: "depth24plus",
      depthWriteEnabled: true,
      depthCompare: "less"
    }
  });

  const depthTex = device.createTexture({
    size: [canvas.width, canvas.height],
    format: "depth24plus",
    usage: GPUTextureUsage.RENDER_ATTACHMENT
  });

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
  });

  // ---------------------------
  // Interaction
  // ---------------------------
  let angleX = 0;
  let angleY = 0;
  let dragging = false;
  let lastX = 0, lastY = 0;

  canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    angleY += (e.clientX - lastX) * 0.01;
    angleX += (e.clientY - lastY) * 0.01;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  // Auto-rotation
  let autoX = 0.4, autoY = 0.6;
  window.addEventListener("keydown", e => {
    if (e.key === "+") { autoX *= 1.2; autoY *= 1.2; }
    if (e.key === "-") { autoX *= 0.8; autoY *= 0.8; }
    if (e.key === "0") { autoX = 0; autoY = 0; }
  });

  let last = performance.now();

  function frame(now) {
    const dt = (now - last) / 1000;
    last = now;

    if (!dragging) {
      angleX += autoX * dt;
      angleY += autoY * dt;
    }

    // Send angles to GPU
    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([angleX, angleY]));

    const colorTex = context.getCurrentTexture();
    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view: colorTex.createView(),
        clearValue: { r:0.1, g:0.1, b:0.12, a:1 },
        loadOp: "clear",
        storeOp: "store"
      }],
      depthStencilAttachment: {
        view: depthTex.createView(),
        depthClearValue: 1,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    });

    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.setVertexBuffer(0, vbuf);
    pass.setIndexBuffer(ibuf, "uint16");
    pass.drawIndexed(indices.length);
    pass.end();

    device.queue.submit([encoder.finish()]);
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

main();
</script>
</body>
</html>
